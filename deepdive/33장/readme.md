# 이벤트

## 이벤트 드리븐 프로그래밍
브라우저는 처리해야 할 특정 사건이 발생하면 이를 감지하여 이벤트를 발생시킨다. (클릭, 키보드 입력, 마우스 이동)

## 이벤트 핸들러
애플리케이션이 특정 타입의 이벤트에 대해 반응하여 어떤 일을 하고 싶다면 해당하는 타입의 이벤트가 발생했을 때 호출될 함수(이벤트 핸들러)를 브라우저에게 알려 호출을 위임한다. 

```
const $button = document.querySelector('button');
$button.onclick = () => { alert('button click')};
```

Window, Document, HTMLElement타입의 객체는 onclick과 같이 특정 이벤트에 대응하는 다양한 이벤트 프로퍼티를 가지고 있다. 

이벤트와 그에 대응하는 함수를 통해 사용자와 애플리케이션은 상호작용을 할 수 있다. 이와 같이 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 `이벤트 드리븐 프로그래밍`이라 한다.

## 이벤트 타입
이벤트 타입은 이벤트의 종류를 나타내는 문자열이다. 타입으론 200여 가지가 존재하며 상세 목록은 ![여기](https://developer.mozilla.org/ko/)에서 확인 할 수 있다.


## 이벤트 핸들러 등록
이벤트가 발생했을 때 브라우저에 호출을 위임한 함수이다. 다시 말해, 이벤트가 발생하면 브라우저에 의해 호출될 함수가 이벤트 핸들러다. DOM객체에 이벤트를 등록하는 방법으론 이벤트 핸들러 어트리뷰트 방식, 이벤트 핸들러 프로퍼티 방식, addEventListener 메서드 방식으로 3가지가 존재한다.

### 이벤트 핸들러 어트리뷰트 방식
HTML 요소의 어트리뷰트 중에는 이벤트에 대응하는 이벤트 핸들러 어트리뷰트가 있다. onclick과 같이 on 접두사와 이벤트의 종류를 나타내는 이벤트 타입으로 이뤄져있다.
함수 호출문 등의 문을 할당하면 이벤트 핸들러가 등록된다.
주의할 점으로 이벤트 핸들러 어트리뷰트 값으로 함수 참조가 아닌 함수 호출문 등의 문을 할당하는 것이다.

CBD(component based development)관련 프레임워크/라이브러리의 경우 이벤트 핸들러 어트리뷰트 방식으로 이벤트를 처리한다.

HTML과 JS가 섞일 우려가 있기때문에 분리를 위해 이벤트 핸들러 프로퍼티 방식을 사용하는 편이 좋다.

### 이벤트 핸들러 프로퍼티 방식
window 객체와 Document, HTMLElement 타입의 DOM 노드 객체는 이벤트에 대응하는 이벤트 핸들러 프로퍼티를 가진다.

이벤트를 발생시킬 객체인 이벤트 타깃, 이벤트의 종류를 나타내는 문자열인 이벤트 타입, 그리고 이벤트 핸들러를 지정할 필요가 있다.

HTML과 자바스크립트가 뒤섞이는 문제를 해결할수잇지만 하나의 이벤트 핸들러만 바인딩할 수 있다는 단점이 있다.

> 이벤트 핸들러 어트리뷰트 방식도 DOM 노드 객체의 이벤트 핸들러 프로퍼티로 변환되므로 결과적으로 이벤트 핸들러 프로퍼티 방식과 동일하다고 볼수있다.


### addEventListener 메서드 방식
EventTarget.prototype.addEventListener 메서드를 사용하여 이벤트 핸들러를 등록할 수 있다.

이벤트 핸들러 프로퍼티 방식은 하나의 이벤트 핸들러만 바인딩하는 것에 대비되어 addEventListener의 경우 여러개의 이벤트 핸들러를 등록할 수 있다.

## 이벤트 핸들러 제거
removeEventListener를 통해서 addEventListener방식으로 생성된 이벤트 핸들러를 삭제할수있다. 다만 이벤트 핸들러의 명을 정확히 입력해야만 삭제된다.

이벤트핸들러 프로퍼티 방식의 경우 null을 재할당하여 삭제가 가능하다.

## 이벤트 객체

이벤트 객체의 경우 ㅈ이벤트 핸들러의 첫번째 인수로 전달되어 매개변수 e에 암묵적으로 할당된다. 이는 브라우저가 이벤트 핸들러를 호출할 때 이벤트 객체를 인수로 전달하기 때문이다. 따라서 이벤트 객체를 전달받으려면 이벤트 핸들러를 정의할 때 이벤트 객체를 전달받을 매개변수를 명시적으로 선언해야 한다.

이벤트 핸들러 어트리뷰트 방식의 경우 어트리뷰트내부에 event를 명시하여 이벤트 객체를 매개변수로 받아 동작하게 된다.
event라 명시하지 않은 경우 해당 객체를 받지 못하게 된다.

사용자가 설정하는 이벤트는 Event.prototype의 객체를 상속받는 형태이다. 따라서 기존에 존재하는 Mouse, KeyBoard 등의 이벤트 객체를 상속받는 과정이 존재한다.


## 이벤트 전파
DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다. 이를 이벤트 전파라고 한다.

```
<html>
    <body>
        <ul id='fruit'>
            <li id="apple">apple</li>
            <li id="banana">banana</li>
            <li id="orange">orange</li>
        </ul>
        <script>
            const fruits = document.getElementById('fruit');
            fruits.addEventListener('click', e=>{
                console.log('이벤트 단계:',e.eventPhase);
                console.log('이벤트 타깃:',e.target);
                console.log('커런트 타깃:',e.currentTarget);
            });
        </script>
    </body>
</html>
```

이벤트 객체는 이벤트를 발생시킨 DOM 요소인 이벤트 타깃을 중심으로 DOM트리를 통해 전파된다. 이벤트 전파는 이벤트 객체가 전파되는 방향에 따라 3단계로 구분된다.

1. 캡처링 단계 : 이벤트가 상위요소에서 하위요소방향으로 전파
2. 타깃 단계 : 이벤트가 이벤트 타깃에 도달
3. 버블링 단계 : 이벤트가 하위 요소에서 상위 요소 방향으로 전파

li 요소를 클릭시에 클릭 이벤트가 발생하여 클릭 이벤트 객체가 생성되고 클릭된 li 요소가 이벤트 타깃이 된다. 클릭 이벤트 객체는 window에서 시작해서 이벤트 타깃 방향으로 전파된다. 이것이 캡처링 단계이다.
이후 이벤트 객체는 이벤트를 발생시킨 이벤트 타깃에 도달한다. 이것이 타깃단계이다.
이후 이벤트 객체는 이벤트 타깃에서 시작해서 window 방향으로 전파된다. 이것이 버블링 단계이다.

이벤트 핸들러 어트리뷰트/프로퍼티 방식으로 등록한 이벤트 핸들러는 타깃 단계와 버블링 단계의 이벤트만 캐치한다. 그에 반해 addEventListener 방식의 경우 캡쳐링단계까지 선별적으로 캐치할 수 있다. 캐치시엔 3번째 인수로 true를 전달해야하며 생략시 어트리뷰트/프로퍼티 방식과 같게 동작하게 된다.

> test2.html에서 확인

이는 이벤트를 발생시킨 이벤트 타깃은 물론 상위 DOM요소에서도 캐치할 수 있다.

버블링이 존재하지 않는 이벤트도 존재하는데 이벤트의 공통 프로퍼티인 event.bubbles의 값이 false인 값들을 볼 수 있다.
- 포커스 : focus/blur
- 리소스 : load/unload/abort/error
- 마우스 : mouseenter/mouseleave

## 이벤트 위임
여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법이다.
