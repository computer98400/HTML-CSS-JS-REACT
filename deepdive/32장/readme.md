# 동기식 처리 모델 vs 비동기식 처리 모델


동기식 처리 모델은 직렬적으로 태스크를 수행한다. 



자바스크립트에서 함수가 실행되려면 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되어야 한다. 다시 말해, 실행 컨텍스트 스택에 함수 실행 컨텍스트가 푸시되는 것은 바로 함수 실행의 시작을 의미한다. 함수가 호출된 순서대로 순차적으로 실행되는 이유는 함수가 호출된 순서대로 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되기 때문이다. 


<b>자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖는다.</b> 이는 자바스크립트가 동기식 처리 모델이라는 말이다. 해당 스택에 들어간 함수는 순차적으로 실행되며 어떤 작업이 수행 중이면 다음 작업은 대기하게 된다.

이런 종류의 방식을 <b>싱글 스레드</b>방식으로 동작한다. 싱글 스레드 방식은 한 번에 하나의 태스크만 실행할 수 있기 때문에 처리에 시간이 걸리는 테스크를 실행하는 경우 <b>블로킹</b>이 발생한다.

> test.js에 내용이 담겨있음.

![image](https://user-images.githubusercontent.com/62691610/165329202-fd4d4708-f0f5-488e-a3c6-ab8ae103389e.png)


```
function func1(){
    console.log('func1');
    func2();
}
function func2(){
    console.log('func2');
    func3();
}
function func3(){
    console.log('func3');
}
func1();

```

setTimeout 함수는 앞서 살펴본 sleep 함수와 유사하게 일정 시간이 경과한 이후에 콜백 함수를 호출하지만 이후 함수의 테스크를 블로킹하지 않고 곧바로 실행한다.
이처럼 현재 실행 중인 테스크가 종료되지 않은 상태라 해도 다음 테스크를 곧바로 실행하는 방식을 <b>비동기처리 모델</b>이라 한다.

비동기식 처리 모델은 병렬적으로 테스크를 수행한다. 즉, 테스크가 종료되지 않은 상태라 하더라도 대기하지 않고 다음 테스크를 실행한다. 예를 들어 서버에서 데이터를 가져와서 화면에 표시하는 테스크를 수행할 때, 서버에 데이터를 요청한 이후 서버로부터 데이터가 응답될 때까지 대기하지 않고 즉시 다음 테스크를 수행한다. 이후 서버로부터 데이터가 응답되면 이벤트가 발생하고 이벤트 핸들러가 데이터를 가지고 수행할 테스크를 계속해 수행한다.

> 자바스크립트의 대부분의 DOM 이벤트 핸들러와 Timer 함수, Ajax요청은 비동기식 처리 모델로 동작한다.


![image](https://user-images.githubusercontent.com/62691610/165325476-8f83501c-77c8-41df-ad8c-8ca7110b98e4.png)


## 이벤트 루프와 태스크 큐
자바스크립트는 비동기 처리 모델을 위한 이벤트 루프가 존재한다.

대부분의 자바스크립트 엔진은 2개의 영역으로 구분할 수 있다.

- 콜스택 : 소스코드 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택자료구조인 실행 컨텍스트 스택이 바로 콜 스택이다.

- 힙 : 객체가 저장되는 메모리 공간이다. 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조한다. 메모리에 값을 저장하려면 먼저 값을 저장할 메모리 공간의 크기를 결정해야 한다. 객체는 원시 값과는 달리 크기가 정해져 있지 않으므로 할당해야 할 메모리 공간의 크기를 런타임에 결정해야 한다.

이처럼 자바스크립트 엔진의 경우 단순히 테스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행할 뿐이다. 그럼 비동기 처리는 어떻게 처리되는가?
이는 브라우저에서 이뤄진다.
settimeout과 같은 비동기 방식의 동작에 앞서 콜백함수의 평가와 실행은 자바스크립트 엔진이 담당하지만 해당 함수의 호출 스케줄링을 위한 타이머 설정과 콜백 함수의 등록은 브라우저가 담당하게 되는 것이다.


- 테스크 큐 : setTimeout이나 setInterval 과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다. 테스크 큐와는 별도로 프로미스의 후속 처리 메서드의 콜백 함수가 일시적으로 보관되는 마이크로테스크 큐도 존재한다. 

- 이벤트 루프 : 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 테스크 큐에 대기 중인 함수가 있는지 반복해서 확인한다. 만약 콜 스택이 비어 있고 테스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적으로 테스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다.

```
function foo() {
    console.log('foo');
}

function bar() {
    console.log('bar');
}

setTimeout(foo, 0);
bar();

```
